task.wait(40)

-- Anti-AFK setup
local VirtualUser = game:GetService("VirtualUser")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local function antiAFK()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end

-- ================ CONFIG ================
local CONFIG = {
    pet_ids = { "moon_2025_hopbop", "moon_2025_snorgle", "some_pet_3", "some_pet_4" },

    goal_normal_count = {
        ["moon_2025_hopbop"] = 0,
        ["moon_2025_snorgle"] = 0,
        ["some_pet_3"] = 0,
        ["some_pet_4"] = 0,
    },

    goal_neon_count = {
        ["moon_2025_hopbop"] = 0,
        ["moon_2025_snorgle"] = 0,
        ["some_pet_3"] = 0,
        ["some_pet_4"] = 0,
    },

    goal_meganeon_count = {
        ["moon_2025_hopbop"] = 1,
        ["moon_2025_snorgle"] = 1,
        ["some_pet_3"] = 0,
        ["some_pet_4"] = 0,
    },

    age_potions_per_pet = {
        ["moon_2025_hopbop"] = 2,
        ["moon_2025_snorgle"] = 3,
        ["some_pet_3"] = 3,
        ["some_pet_4"] = 3,
    },

    neon_age_potions_per_pet = {
        ["moon_2025_hopbop"] = 2,
        ["moon_2025_snorgle"] = 3,
        ["some_pet_3"] = 2,
        ["some_pet_4"] = 2,
    },

    webhook_url = "https://discord.com/api/webhooks/1404060448692895824/tsUAjiD8JQlgL93NqgvQUhmU0k7u9pjaRJ9R2KtVulc8TlmLY-jze_jiv7U7u9qv64wj",
    discord_ping_id = "1277143046173229097",

    anti_afk_interval = 60,
    data_refresh_interval = 5,
}
-- ========================================

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local character = player.Character or player.CharacterAdded:Wait()

local ClientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
local EquipPetRemote = ReplicatedStorage.API["ToolAPI/Equip"]
local FeedPotionRemote = ReplicatedStorage.API["PetObjectAPI/CreatePetObject"]
local NeonFusionRemote = ReplicatedStorage.API["PetAPI/DoNeonFusion"]

local latestPets = {}
local latestPotions = {}

-- Webhook helper functions

local function sendWebhookMessage(message, ping)
    local content = message
    if ping then
        content = string.format("<@!%s> %s", CONFIG.discord_ping_id, message)
    end
    local data = {
        content = content
    }
    local jsonData = HttpService:JSONEncode(data)
    local success, err = pcall(function()
        HttpService:RequestAsync({
            Url = CONFIG.webhook_url,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = jsonData,
        })
    end)
    if not success then warn("Webhook message failed:", err) end
end

local function sendWebhookEmbed(title, description, ping)
    local content = ""
    if ping then
        content = string.format("<@!%s>", CONFIG.discord_ping_id)
    end
    local data = {
        content = content,
        embeds = {{
            title = title,
            description = description,
            color = 0x00FF00,
            footer = { text = "Pet Script Notification" }
        }}
    }
    local jsonData = HttpService:JSONEncode(data)
    local success, err = pcall(function()
        HttpService:RequestAsync({
            Url = CONFIG.webhook_url,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = jsonData,
        })
    end)
    if not success then warn("Webhook embed failed:", err) end
end

-- Refresh local inventory data every CONFIG.data_refresh_interval seconds
coroutine.wrap(function()
    while true do
        local data = ClientData.getdata and ClientData.getdata() or ClientData.get_data and ClientData.get_data()
        if data and data[player.Name] and data[player.Name].inventory then
            latestPets = data[player.Name].inventory.pets or {}
            latestPotions = {}
            for _, item in pairs(data[player.Name].inventory.food or {}) do
                if item.kind == "pet_age_potion" then
                    table.insert(latestPotions, item)
                end
            end
        else
            latestPets = {}
            latestPotions = {}
        end
        task.wait(CONFIG.data_refresh_interval)
    end
end)()

local function potionExists(uniqueID)
    for _, pot in pairs(latestPotions) do
        if pot.unique == uniqueID then
            return true
        end
    end
    return false
end

local function equipPet(encodedPetId)
    local args = {
        [1] = encodedPetId,
        [2] = {
            ["use_sound_delay"] = true,
            ["equip_as_last"] = false,
        },
    }
    local success, err = pcall(function()
        EquipPetRemote:InvokeServer(unpack(args))
    end)
    if not success then
        warn("Failed to equip pet:", encodedPetId, err)
    else
        print("Equipped pet:", encodedPetId)
    end
end

local function feedOnePotionAndWaitForConsume(petEncodedID, potionUniqueID)
    local myCFrame = character:FindFirstChild("HumanoidRootPart") and character.HumanoidRootPart.CFrame or CFrame.new()
    local args = {
        [1] = "__Enum_PetObjectCreatorType_2",
        [2] = {
            ["pet_unique"] = petEncodedID,
            ["spawn_cframe"] = myCFrame,
            ["additional_consume_uniques"] = {},
            ["unique_id"] = potionUniqueID,
        }
    }

    print("Feeding potion", potionUniqueID, "to pet", petEncodedID)
    local success, result = pcall(function()
        return FeedPotionRemote:InvokeServer(unpack(args))
    end)
    if not success then
        warn("Feed failed:", result)
        return false
    end

    for i = 1, 100 do
        task.wait(0.1)
        if not potionExists(potionUniqueID) then
            print("Potion", potionUniqueID, "consumed")
            return true
        end
    end

    warn("Potion", potionUniqueID, "not consumed after 10 seconds")
    return true
end

local function feedPetOneByOne(pet, potionsCount)
    local potionsUsed = 0
    if potionsCount > #latestPotions then
        potionsCount = #latestPotions
        warn("Not enough potions available, feeding only " .. potionsCount)
    end
    for i = 1, potionsCount do
        local potion = latestPotions[i]
        local success = feedOnePotionAndWaitForConsume(pet.unique, potion.unique)
        if not success then break end
        potionsUsed = potionsUsed + 1
    end
    return potionsUsed
end

local function countPetsByType(petID)
    local normal = 0
    local neon = 0
    local mega = 0
    for _, pet in pairs(latestPets) do
        if pet.id == petID and pet.properties then
            local isNeon = pet.properties.neon
            local isMega = pet.properties.mega_neon
            local age = pet.properties.age or 0
            if isMega then
                mega = mega + 1
            elseif isNeon then
                neon = neon + 1
            elseif age >= 6 then
                normal = normal + 1
            end
        end
    end
    return normal, neon, mega
end

local function makeNeon(petID)
    local candidates = {}
    for _, pet in pairs(latestPets) do
        if pet.id == petID and pet.properties and pet.properties.age == 6 and not pet.properties.neon then
            table.insert(candidates, pet.unique)
        end
    end
    while #candidates >= 4 do
        local group = {table.unpack(candidates, 1, 4)}
        print("Making pets neon:", table.concat(group, ", "))
        local args = { [1] = group }
        local success, err = pcall(function()
            NeonFusionRemote:InvokeServer(unpack(args))
        end)
        if not success then
            warn("Failed to make neon:", err)
            break
        end

        sendWebhookEmbed("✨ Neon Fusion Performed", string.format("Player %s performed neon fusion on pets: %s", player.Name, table.concat(group, ", ")), false)
        for i = 1, 4 do
            table.remove(candidates, 1)
        end
        task.wait(2)
    end
end

local function makeMegaNeon(petID)
    local candidates = {}
    for _, pet in pairs(latestPets) do
        if pet.id == petID and pet.properties and pet.properties.neon and pet.properties.age == 6 and not pet.properties.mega_neon then
            table.insert(candidates, pet.unique)
        end
    end
    while #candidates >= 4 do
        local group = {table.unpack(candidates, 1, 4)}
        print("Making mega neon for pets:", table.concat(group, ", "))
        local args = { [1] = group }
        local success, err = pcall(function()
            NeonFusionRemote:InvokeServer(unpack(args))
        end)
        if not success then
            warn("Failed to make mega neon:", err)
            break
        end

        sendWebhookEmbed("🌟 Mega Neon Fusion Performed", string.format("Player %s performed mega neon fusion on pets: %s", player.Name, table.concat(group, ", ")), false)
        for i = 1, 4 do
            table.remove(candidates, 1)
        end
        task.wait(3)
    end
end

local afkTimer = 0

local function kickPlayerWithReason(reason, ping)
    sendWebhookMessage(string.format("⚠️ Player %s kicked: %s", player.Name, reason), ping)
    task.wait(2)
    player:Kick(reason)
end

local function doFeedingAndFusion()
    local performedAnyAction = false

    for _, petID in ipairs(CONFIG.pet_ids) do
        local normalCount, neonCount, megaCount = countPetsByType(petID)
        local goalNormal = CONFIG.goal_normal_count[petID] or 0
        local goalNeon = CONFIG.goal_neon_count[petID] or 0
        local goalMega = CONFIG.goal_meganeon_count[petID] or 0

        if goalMega > 0 and megaCount < goalMega then
            makeMegaNeon(petID)
            normalCount, neonCount, megaCount = countPetsByType(petID)
        end

        if goalMega == 0 or megaCount < goalMega then
            if neonCount < goalNeon then
                for _, pet in pairs(latestPets) do
                    if pet.id == petID and pet.properties and pet.properties.neon and (pet.properties.age or 0) < 6 then
                        local potionsNeeded = CONFIG.neon_age_potions_per_pet[petID] or 1
                        if #latestPotions < potionsNeeded then
                            kickPlayerWithReason("Not enough age potions to age neon pets.", true)
                            return false
                        end
                        equipPet(pet.unique)
                        task.wait(1)
                        local potionsUsed = feedPetOneByOne(pet, potionsNeeded)
                        performedAnyAction = performedAnyAction or (potionsUsed > 0)
                        task.wait(1)
                    end
                end
                makeNeon(petID)
                normalCount, neonCount, megaCount = countPetsByType(petID)
            end
        end

        if (goalNeon == 0 or neonCount >= goalNeon) and normalCount < goalNormal then
            for _, pet in pairs(latestPets) do
                if pet.id == petID and pet.properties and not pet.properties.neon and (pet.properties.age or 0) < 6 then
                    local potionsNeeded = CONFIG.age_potions_per_pet[petID] or 2
                    if #latestPotions < potionsNeeded then
                        kickPlayerWithReason("Not enough age potions to age normal pets.", true)
                        return false
                    end
                    equipPet(pet.unique)
                    task.wait(1)
                    local potionsUsed = feedPetOneByOne(pet, potionsNeeded)
                    performedAnyAction = performedAnyAction or (potionsUsed > 0)
                    task.wait(1)
                end
            end
            if goalNeon > 0 then
                makeNeon(petID)
            end
        end
    end

    local allGoalsMet = true
    local statusLines = {}
    for _, petID in ipairs(CONFIG.pet_ids) do
        local normalCount, neonCount, megaCount = countPetsByType(petID)
        local goalNormal = CONFIG.goal_normal_count[petID] or 0
        local goalNeon = CONFIG.goal_neon_count[petID] or 0
        local goalMega = CONFIG.goal_meganeon_count[petID] or 0
        if normalCount < goalNormal or neonCount < goalNeon or megaCount < goalMega then
            allGoalsMet = false
        end
        table.insert(statusLines, string.format("%s: Normal %d/%d | Neon %d/%d | Mega %d/%d", petID, normalCount, goalNormal, neonCount, goalNeon, megaCount, goalMega))
    end

    if allGoalsMet then
        sendWebhookEmbed("✅ All pet goals met!", "Player " .. player.Name .. "\n" .. table.concat(statusLines, "\n"), true)
        kickPlayerWithReason("All pet goals met, task complete.", false)
        return false
    elseif not performedAnyAction then
        sendWebhookEmbed("ℹ️ No action needed, no tasks left.", "Player " .. player.Name .. "\n" .. table.concat(statusLines, "\n"), false)
        kickPlayerWithReason("No tasks left to perform, script stopping.", false)
        return false
    end

    return true
end

-- Main loop
spawn(function()
    while true do
        afkTimer = afkTimer + CONFIG.data_refresh_interval
        if afkTimer >= CONFIG.anti_afk_interval then
            antiAFK()
            afkTimer = 0
        end

        local continueScript = doFeedingAndFusion()
        if not continueScript then break end

        task.wait(CONFIG.data_refresh_interval)
    end
end)
