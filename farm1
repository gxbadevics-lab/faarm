task.wait(50)

-- Anti-AFK setup
local VirtualUser = game:GetService("VirtualUser")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local function antiAFK()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end

-- ===================== CONFIG =====================
local CONFIG = {
    pet_id_goal = { "moon_2025_hopbop", "moon_2025_snorgle" }, -- pets to process

    -- Goals for each pet ID (total counts in inventory you want)
    goal_normal_count = {
        ["moon_2025_hopbop"] = 0,
        ["moon_2025_snorgle"] = 0,
    },
    goal_neon_count = {
        ["moon_2025_hopbop"] = 0,
        ["moon_2025_snorgle"] = 0,
    },
    goal_meganeon_count = {
        ["moon_2025_hopbop"] = 1,
        ["moon_2025_snorgle"] = 1,
    },

    -- Potions to use per pet type (how many potions to feed at a time)
    age_potions_per_pet = {
        ["moon_2025_hopbop"] = 2,
        ["beach_2024_gold_mahi_mahi"] = 3,
    },
    neon_age_potions_per_pet = {
        ["moon_2025_hopbop"] = 2,
        ["beach_2024_gold_mahi_mahi"] = 3,
    },

    -- Other toggles
    neon_maker = true,
    neon_feeder = true,

    webhook_url = "https://discord.com/api/webhooks/1404060448692895824/tsUAjiD8JQlgL93NqgvQUhmU0k7u9pjaRJ9R2KtVulc8TlmLY-jze_jiv7U7u9qv64wj",
    webhook_ping_id = "1277143046173229097",
}
-- ===================================================

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local character = player.Character or player.CharacterAdded:Wait()

local ClientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
local EquipPetRemote = ReplicatedStorage.API["ToolAPI/Equip"]
local FeedPotionRemote = ReplicatedStorage.API["PetObjectAPI/CreatePetObject"]
local NeonFusionRemote = ReplicatedStorage.API["PetAPI/DoNeonFusion"]

local latestPets = {}
local latestPotions = {}

-- Webhook functions
local function SendMessage(url, message)
    local headers = { ["Content-Type"] = "application/json" }
    local data = { ["content"] = "<@!" .. CONFIG.webhook_ping_id .. "> " .. message }
    local body = HttpService:JSONEncode(data)
    request({
        Url = url,
        Method = "POST",
        Headers = headers,
        Body = body
    })
    print("Webhook message sent")
end

local function SendMessageEMBED(url, embed)
    local headers = { ["Content-Type"] = "application/json" }
    local data = {
        ["content"] = "<@!" .. CONFIG.webhook_ping_id .. ">",
        ["embeds"] = {{
            ["title"] = embed.title,
            ["description"] = embed.description,
            ["color"] = embed.color,
            ["fields"] = embed.fields or {},
            ["footer"] = { ["text"] = embed.footer.text or "" }
        }}
    }
    local body = HttpService:JSONEncode(data)
    request({
        Url = url,
        Method = "POST",
        Headers = headers,
        Body = body
    })
    print("Webhook embed sent")
end

local function sendWebhookMessage(msg) SendMessage(CONFIG.webhook_url, msg) end
local function sendWebhookEmbed(embed) SendMessageEMBED(CONFIG.webhook_url, embed) end

-- Data refresh coroutine
coroutine.wrap(function()
    while true do
        local data = ClientData.getdata and ClientData.getdata() or ClientData.get_data and ClientData.get_data()
        if data and data[player.Name] and data[player.Name].inventory then
            latestPets = data[player.Name].inventory.pets or {}
            latestPotions = {}
            for _, item in pairs(data[player.Name].inventory.food or {}) do
                if item.kind == "pet_age_potion" then
                    table.insert(latestPotions, item)
                end
            end
        else
            latestPets = {}
            latestPotions = {}
        end
        task.wait(5)
    end
end)()

-- Utility: count pets by form and age
local function countPetsByTypeAndAge(petID)
    local normalCount, normalAgedCount = 0, 0
    local neonCount, neonAgedCount = 0, 0
    local megaNeonCount = 0

    for _, pet in pairs(latestPets) do
        if pet.id == petID then
            local age = pet.properties and pet.properties.age or 0
            local isNeon = pet.properties and pet.properties.neon
            local isMega = pet.properties and pet.properties.mega_neon

            if isMega then
                megaNeonCount = megaNeonCount + 1
            elseif isNeon then
                neonCount = neonCount + 1
                if age == 6 then
                    neonAgedCount = neonAgedCount + 1
                end
            else
                normalCount = normalCount + 1
                if age == 6 then
                    normalAgedCount = normalAgedCount + 1
                end
            end
        end
    end

    return normalCount, normalAgedCount, neonCount, neonAgedCount, megaNeonCount
end

local function potionExists(uniqueID)
    for _, pot in pairs(latestPotions) do
        if pot.unique == uniqueID then return true end
    end
    return false
end

local function equipPet(encodedPetId)
    local args = {
        [1] = encodedPetId,
        [2] = {
            ["use_sound_delay"] = true,
            ["equip_as_last"] = false,
        },
    }
    local success, err = pcall(function()
        EquipPetRemote:InvokeServer(unpack(args))
    end)
    if not success then warn("Failed to equip pet:", encodedPetId, err)
    else print("Equipped pet:", encodedPetId)
    end
end

local function feedOnePotionAndWaitForConsume(petEncodedID, potionUniqueID)
    local myCFrame = character:FindFirstChild("HumanoidRootPart") and character.HumanoidRootPart.CFrame or CFrame.new()
    local args = {
        [1] = "__Enum_PetObjectCreatorType_2",
        [2] = {
            ["pet_unique"] = petEncodedID,
            ["spawn_cframe"] = myCFrame,
            ["additional_consume_uniques"] = {},
            ["unique_id"] = potionUniqueID,
        }
    }

    print("Feeding potion", potionUniqueID, "to pet", petEncodedID)
    local success, result = pcall(function()
        return FeedPotionRemote:InvokeServer(unpack(args))
    end)
    if not success then
        warn("Feed failed:", result)
        return false
    end

    for i = 1, 100 do
        task.wait(0.1)
        if not potionExists(potionUniqueID) then
            print("Potion", potionUniqueID, "consumed")
            return true
        end
    end
    warn("Potion", potionUniqueID, "not consumed after 10 seconds")
    return true
end

local function feedPetOneByOne(pet, potionsCount)
    local potionsUsed = 0
    if potionsCount > #latestPotions then
        potionsCount = #latestPotions
        warn("Not enough potions available, feeding only " .. potionsCount)
    end
    for i = 1, potionsCount do
        local potion = latestPotions[i]
        local success = feedOnePotionAndWaitForConsume(pet.unique, potion.unique)
        if not success then break end
        potionsUsed = potionsUsed + 1
    end
    return potionsUsed
end

-- Fuse neon pets (4 aged 6 normal pets)
local function makeNeonForPet(petID)
    if not CONFIG.neon_maker then return end
    local candidates = {}
    for _, pet in pairs(latestPets) do
        if pet.id == petID and pet.properties and pet.properties.age == 6 and not pet.properties.neon and not pet.properties.mega_neon then
            table.insert(candidates, pet.unique)
        end
    end

    while #candidates >= 4 do
        local group = {table.unpack(candidates, 1, 4)}
        print("Making pets neon:", table.concat(group, ", "))
        local args = { [1] = group }
        local success, err = pcall(function()
            NeonFusionRemote:InvokeServer(unpack(args))
        end)
        if not success then
            warn("Failed to make neon:", err)
            break
        end

        sendWebhookEmbed({
            title = "✨ Neon Fusion Performed",
            description = string.format("Player %s performed neon fusion on pets (petID: %s): %s", player.Name, petID, table.concat(group, ", ")),
            color = 0x00FF00,
            fields = {},
            footer = { text = "Pet Neon Notification" }
        })

        for i = 1, 4 do table.remove(candidates, 1) end
        task.wait(2)
    end
end

-- Fuse mega neon pets (4 neon pets)
local function makeMegaNeonForPet(petID)
    local candidates = {}
    for _, pet in pairs(latestPets) do
        if pet.id == petID and pet.properties and pet.properties.neon and not pet.properties.mega_neon then
            table.insert(candidates, pet.unique)
        end
    end

    while #candidates >= 4 do
        local group = {table.unpack(candidates, 1, 4)}
        print("Making pets mega neon:", table.concat(group, ", "))
        local args = { [1] = group }
        local success, err = pcall(function()
            NeonFusionRemote:InvokeServer(unpack(args))
        end)
        if not success then
            warn("Failed to make mega neon:", err)
            break
        end

        sendWebhookEmbed({
            title = "🌟 Mega Neon Fusion Performed",
            description = string.format("Player %s performed mega neon fusion on pets (petID: %s): %s", player.Name, petID, table.concat(group, ", ")),
            color = 0xFFD700,
            fields = {},
            footer = { text = "Pet Mega Neon Notification" }
        })

        for i = 1, 4 do table.remove(candidates, 1) end
        task.wait(2)
    end
end

local function feedPetsLoop(normalFeed, neonFeed)
    for _, petID in ipairs(CONFIG.pet_id_goal) do
        local normalCount, normalAgedCount, neonCount, neonAgedCount, megaNeonCount = countPetsByTypeAndAge(petID)
        local goalNormal = CONFIG.goal_normal_count[petID] or 0
        local goalNeon = CONFIG.goal_neon_count[petID] or 0
        local goalMega = CONFIG.goal_meganeon_count[petID] or 0

        -- If mega neon goal met, skip all other feeding for this pet
        if goalMega > 0 and megaNeonCount >= goalMega then
            print("Mega neon goal met for", petID)
            goto continue
        end

        -- If neon goal met and mega neon goal is 0, skip normal feeding if normal goal is met
        if goalMega == 0 and goalNeon > 0 and neonCount >= goalNeon and normalCount >= goalNormal then
            print("Neon and normal goals met for", petID)
            goto continue
        end

        -- Feed normal pets (if normalFeed = true)
        if normalFeed and normalCount < goalNormal then
            local toFeedCount = goalNormal - normalCount
            local potionsToUse = CONFIG.age_potions_per_pet[petID] or 1
            print(string.format("Feeding normal pets for %s. Need to feed %d pets with %d potions each", petID, toFeedCount, potionsToUse))
            local fedCount = 0
            for _, pet in pairs(latestPets) do
                if pet.id == petID and not (pet.properties and pet.properties.neon) and not (pet.properties and pet.properties.mega_neon) and pet.properties.age < 6 then
                    equipPet(pet.unique)
                    task.wait(1)
                    local potionsUsed = feedPetOneByOne(pet, potionsToUse)
                    if potionsUsed > 0 then
                        fedCount = fedCount + 1
                        sendWebhookMessage(string.format("🐾 %s aged normal pet %s (%d/%d)", player.Name, petID, fedCount, toFeedCount))
                    end
                    task.wait(1)
                    if fedCount >= toFeedCount then break end
                end
            end
        end

        -- Feed neon pets (if neonFeed = true)
        if neonFeed and neonCount < goalNeon then
            local toFeedCount = goalNeon - neonCount
            local potionsToUse = CONFIG.neon_age_potions_per_pet[petID] or 1
            print(string.format("Feeding neon pets for %s. Need to feed %d pets with %d potions each", petID, toFeedCount, potionsToUse))
            local fedCount = 0
            for _, pet in pairs(latestPets) do
                if pet.id == petID and (pet.properties and pet.properties.neon) and not (pet.properties and pet.properties.mega_neon) and pet.properties.age < 6 then
                    equipPet(pet.unique)
                    task.wait(1)
                    local potionsUsed = feedPetOneByOne(pet, potionsToUse)
                    if potionsUsed > 0 then
                        fedCount = fedCount + 1
                        sendWebhookMessage(string.format("🐾 %s aged neon pet %s (%d/%d)", player.Name, petID, fedCount, toFeedCount))
                    end
                    task.wait(1)
                    if fedCount >= toFeedCount then break end
                end
            end
        end

        -- Try to make neon (4 normal pets age 6 fusion)
        if CONFIG.neon_maker and goalNeon > 0 and normalCount >= 4 then
            makeNeonForPet(petID)
        end

        -- Try to make mega neon (4 neon pets fusion)
        if goalMega > 0 and neonCount >= 4 then
            makeMegaNeonForPet(petID)
        end

        ::continue::
    end
end

local function allGoalsMet()
    for _, petID in ipairs(CONFIG.pet_id_goal) do
        local normalCount, _, neonCount, _, megaNeonCount = countPetsByTypeAndAge(petID)
        local goalNormal = CONFIG.goal_normal_count[petID] or 0
        local goalNeon = CONFIG.goal_neon_count[petID] or 0
        local goalMega = CONFIG.goal_meganeon_count[petID] or 0

        if goalMega > 0 and megaNeonCount < goalMega then
            return false
        end
        if goalNeon > 0 and neonCount < goalNeon then
            return false
        end
        if goalNormal > 0 and normalCount < goalNormal then
            return false
        end
    end
    return true
end

local function generateSummary()
    local lines = {}
    for _, petID in ipairs(CONFIG.pet_id_goal) do
        local normalCount, normalAgedCount, neonCount, neonAgedCount, megaNeonCount = countPetsByTypeAndAge(petID)
        table.insert(lines, string.format("PetID: %s | Normal: %d (aged 6: %d) | Neon: %d (aged 6: %d) | Mega Neon: %d", petID, normalCount, normalAgedCount, neonCount, neonAgedCount, megaNeonCount))
    end
    return table.concat(lines, "\n")
end

-- Main loop
while true do
    antiAFK()
    feedPetsLoop(true, true)

    if allGoalsMet() then
        local summary = generateSummary()
        sendWebhookMessage(string.format("✅ All goals reached for player **%s**!\n%s", player.Name, summary))
        player:Kick("All pet goals completed!")
        break
    end

    task.wait(5)
end
