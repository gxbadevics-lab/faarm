task.wait(40)
-- Anti-AFK setup
local VirtualUser = game:GetService("VirtualUser")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local function antiAFK()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end

-- ===================== CONFIG =====================
local CONFIG = {
    pet_ids = { "moon_2025_hopbop", "moon_2025_snorgle", "some_pet_3", "some_pet_4" },

    age_potions_per_pet = {
        ["moon_2025_hopbop"] = 2,
        ["moon_2025_snorgle"] = 3,
        ["some_pet_3"] = 4,
        ["some_pet_4"] = 5,
    },
    neon_age_potions_per_pet = {
        ["moon_2025_hopbop"] = 2,
        ["moon_2025_snorgle"] = 3,
        ["some_pet_3"] = 3,
        ["some_pet_4"] = 4,
    },

    -- Leave these empty or fill later
    goal_normal_count = {}, -- e.g. ["moon_2025_hopbop"] = 16
    goal_neon_count = {},   -- e.g. ["moon_2025_hopbop"] = 4
    goal_meganeon_count = {
        ["moon_2025_hopbop"] = 1,
        ["moon_2025_snorgle"] = 1,
        ["some_pet_3"] = 0,
        ["some_pet_4"] = 0,
    },

    neon_maker = true,
    neon_feeder = true,
    mega_neon_maker = true,

    webhook_url = "https://discord.com/api/webhooks/1404060448692895824/tsUAjiD8JQlgL93NqgvQUhmU0k7u9pjaRJ9R2KtVulc8TlmLY-jze_jiv7U7u9qv64wj",
    webhook_ping_id = "1277143046173229097",
}
-- ===================================================

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local character = player.Character or player.CharacterAdded:Wait()

local ClientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
local EquipPetRemote = ReplicatedStorage.API["ToolAPI/Equip"]
local FeedPotionRemote = ReplicatedStorage.API["PetObjectAPI/CreatePetObject"]
local NeonFusionRemote = ReplicatedStorage.API["PetAPI/DoNeonFusion"]

local latestPets = {}
local latestPotions = {}

local function SendMessage(url, message)
    local headers = {["Content-Type"] = "application/json"}
    local data = {["content"] = message}
    local body = HttpService:JSONEncode(data)
    request({Url = url, Method = "POST", Headers = headers, Body = body})
    print("Webhook message sent")
end

local function SendMessageEMBED(title, description, ping)
    local headers = {["Content-Type"] = "application/json"}
    local data = {
        ["content"] = ping and ("<@!"..CONFIG.webhook_ping_id..">") or "",
        ["embeds"] = {{
            ["title"] = title,
            ["description"] = description,
            ["color"] = ping and 0xFF0000 or 0x00FF00,
            ["footer"] = {["text"] = "Pet Automation Script"}
        }}
    }
    local body = HttpService:JSONEncode(data)
    request({Url = CONFIG.webhook_url, Method = "POST", Headers = headers, Body = body})
    print("Webhook embed sent: "..title)
end

local function sendWebhookMessage(msg)
    SendMessage(CONFIG.webhook_url, msg)
end

local function sendWebhookEmbed(title, description, ping)
    SendMessageEMBED(title, description, ping)
end

coroutine.wrap(function()
    while true do
        local data = ClientData.getdata and ClientData.getdata() or ClientData.get_data and ClientData.get_data()
        if data and data[player.Name] and data[player.Name].inventory then
            latestPets = data[player.Name].inventory.pets or {}
            latestPotions = {}
            for _, item in pairs(data[player.Name].inventory.food or {}) do
                if item.kind == "pet_age_potion" then
                    table.insert(latestPotions, item)
                end
            end
        else
            latestPets = {}
            latestPotions = {}
        end
        task.wait(5)
    end
end)()

local function potionExists(uniqueID)
    for _, pot in pairs(latestPotions) do
        if pot.unique == uniqueID then return true end
    end
    return false
end

local function equipPet(encodedPetId)
    local args = {[1] = encodedPetId, [2] = {use_sound_delay=true, equip_as_last=false}}
    local success, err = pcall(function()
        EquipPetRemote:InvokeServer(unpack(args))
    end)
    if not success then warn("Failed to equip pet:", encodedPetId, err) else print("Equipped pet:", encodedPetId) end
end

local function feedOnePotionAndWaitForConsume(petEncodedID, potionUniqueID)
    local myCFrame = character:FindFirstChild("HumanoidRootPart") and character.HumanoidRootPart.CFrame or CFrame.new()
    local args = {
        [1] = "__Enum_PetObjectCreatorType_2",
        [2] = {
            pet_unique = petEncodedID,
            spawn_cframe = myCFrame,
            additional_consume_uniques = {},
            unique_id = potionUniqueID,
        }
    }
    print("Feeding potion", potionUniqueID, "to pet", petEncodedID)
    local success, result = pcall(function() return FeedPotionRemote:InvokeServer(unpack(args)) end)
    if not success then warn("Feed failed:", result) return false end
    for i = 1, 100 do
        task.wait(0.1)
        if not potionExists(potionUniqueID) then
            print("Potion", potionUniqueID, "consumed")
            return true
        end
    end
    warn("Potion", potionUniqueID, "not consumed after 10 seconds")
    return true
end

local function feedPetOneByOne(pet, potionsCount)
    local potionsUsed = 0
    if potionsCount > #latestPotions then potionsCount = #latestPotions end
    for i = 1, potionsCount do
        local potion = latestPotions[i]
        local success = feedOnePotionAndWaitForConsume(pet.unique, potion.unique)
        if not success then break end
        potionsUsed = potionsUsed + 1
    end
    return potionsUsed
end

local function countPetsByType()
    local counts = {}
    for _, petID in ipairs(CONFIG.pet_ids) do
        counts[petID] = {normal=0, neon=0, mega=0}
    end
    for _, pet in pairs(latestPets) do
        local pid = pet.id
        if counts[pid] then
            local props = pet.properties or {}
            if props.mega_neon then
                counts[pid].mega = counts[pid].mega + 1
            elseif props.neon then
                counts[pid].neon = counts[pid].neon + 1
            else
                counts[pid].normal = counts[pid].normal + 1
            end
        end
    end
    return counts
end

local function getPetNamesFromUniques(uniques)
    local names = {}
    for _, unique in ipairs(uniques) do
        for _, pet in pairs(latestPets) do
            if pet.unique == unique then
                table.insert(names, pet.id)
                break
            end
        end
    end
    return names
end

local function makeNeonFusion()
    if not CONFIG.neon_maker then return end
    for _, petID in ipairs(CONFIG.pet_ids) do
        local normalAge6Pets = {}
        for _, pet in pairs(latestPets) do
            if pet.id == petID and pet.properties and pet.properties.age == 6 and not pet.properties.neon and not pet.properties.mega_neon then
                table.insert(normalAge6Pets, pet.unique)
            end
        end
        while #normalAge6Pets >= 4 do
            local group = {table.unpack(normalAge6Pets, 1, 4)}
            local petNames = table.concat(getPetNamesFromUniques(group), ", ")
            print("Making pets neon:", petNames)
            local args = {[1] = group}
            local success, err = pcall(function()
                NeonFusionRemote:InvokeServer(unpack(args))
            end)
            if not success then
                warn("Failed to make neon:", err)
                break
            end
            sendWebhookEmbed(
                "âœ¨ Neon Fusion Performed",
                string.format("Player %s performed neon fusion on pets: %s", player.Name, petNames),
                false
            )
            for i = 1, 4 do table.remove(normalAge6Pets, 1) end
            task.wait(2)
        end
    end
end

local function makeMegaNeonFusion()
    if not CONFIG.mega_neon_maker then return end
    for _, petID in ipairs(CONFIG.pet_ids) do
        local neonAge6Pets = {}
        for _, pet in pairs(latestPets) do
            if pet.id == petID and pet.properties and pet.properties.age == 6 and pet.properties.neon and not pet.properties.mega_neon then
                table.insert(neonAge6Pets, pet.unique)
            end
        end
        while #neonAge6Pets >= 4 do
            local group = {table.unpack(neonAge6Pets, 1, 4)}
            local petNames = table.concat(getPetNamesFromUniques(group), ", ")
            print("Making pets mega neon:", petNames)
            local args = {[1] = group}
            local success, err = pcall(function()
                NeonFusionRemote:InvokeServer(unpack(args))
            end)
            if not success then
                warn("Failed to make mega neon:", err)
                break
            end
            sendWebhookEmbed(
                "ðŸŒŸ Mega Neon Fusion Performed",
                string.format("Player %s performed mega neon fusion on pets: %s", player.Name, petNames),
                true
            )
            for i = 1, 4 do table.remove(neonAge6Pets, 1) end
            task.wait(2)
        end
    end
end

local function feedPets(normalFeed, neonFeed)
    for _, petID in ipairs(CONFIG.pet_ids) do
        local potionsToFeed = normalFeed and (CONFIG.age_potions_per_pet[petID] or 1) or (CONFIG.neon_age_potions_per_pet[petID] or 1)
        for _, pet in pairs(latestPets) do
            if pet.id == petID then
                local isNeon = pet.properties and pet.properties.neon
                if (normalFeed and not isNeon) or (neonFeed and isNeon) then
                    equipPet(pet.unique)
                    task.wait(1)
                    print(string.format("Feeding %s pet [%s] Age: %d Neon: %s with %d potions", petID, pet.unique, pet.properties.age or 0, tostring(isNeon), potionsToFeed))
                    feedPetOneByOne(pet, potionsToFeed)
                    task.wait(1)
                end
            end
        end
    end
end

local afkTimer = 0
local afkInterval = 60 -- seconds

while true do
    afkTimer = afkTimer + 5
    if afkTimer >= afkInterval then
        antiAFK()
        afkTimer = 0
    end

    local counts = countPetsByType()

    -- Check if mega goals are met
    local allMegaGoalsMet = true
    for _, petID in ipairs(CONFIG.pet_ids) do
        local megaGoal = CONFIG.goal_meganeon_count[petID] or 0
        local megaHave = counts[petID].mega or 0
        if megaHave < megaGoal then
            allMegaGoalsMet = false
            break
        end
    end

    if allMegaGoalsMet then
        local summaryLines = {}
        for _, petID in ipairs(CONFIG.pet_ids) do
            local c = counts[petID]
            table.insert(summaryLines, string.format("%s: Normal %d/%d | Neon %d/%d | Mega %d/%d",
                petID,
                c.normal, CONFIG.goal_normal_count[petID] or 0,
                c.neon, CONFIG.goal_neon_count[petID] or 0,
                c.mega, CONFIG.goal_meganeon_count[petID] or 0))
        end
        sendWebhookEmbed(
            "â„¹ï¸ All mega neon goals met! No more tasks.",
            string.format("Player %s\n%s", player.Name, table.concat(summaryLines, "\n")),
            true
        )
        player:Kick("All mega neon goals met, script finished.")
        break
    end

    -- Check potions availability
    if #latestPotions == 0 then
        sendWebhookEmbed(
            "âš ï¸ Not enough age potions!",
            string.format("Player %s has no pet age potions to continue.", player.Name),
            true
        )
        player:Kick("No pet age potions left, script stopped.")
        break
    end

    -- Feed normal pets
    feedPets(true, false)

    -- Feed neon pets
    if CONFIG.neon_feeder then
        feedPets(false, true)
    end

    -- Make neon fusion from 4 normal age 6 pets
    makeNeonFusion()

    -- Make mega neon fusion from 4 neon age 6 pets
    makeMegaNeonFusion()

    task.wait(10)
end
