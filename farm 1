--// CONFIG
task.spawn(function()
    getgenv().Config = {
        inventory = "pets",
        username = "m4alt_3", -- target username
        pets_to_trade = {
            "winter_2025_xmas_tree_sasquatch",
            "winter_2025_xmas_tree_sasquatch,neon",
            "winter_2025_maine_coon",
            "winter_2025_maine_coon,neon",
            "winter_2025_maine_coon,mega"
        }
    }
end)

-------------------------------------------------
-- STARTUP CHECKS (unchanged)
-------------------------------------------------
repeat task.wait(1) until game:IsLoaded()
    and game:GetService("ReplicatedStorage"):FindFirstChild("ClientModules")
    and game:GetService("ReplicatedStorage").ClientModules:FindFirstChild("Core")
    and game:GetService("ReplicatedStorage").ClientModules.Core:FindFirstChild("UIManager")

repeat task.wait(1) until game.Players.LocalPlayer.PlayerGui:FindFirstChild("AssetLoadUI")
    and game.Players.LocalPlayer.PlayerGui.AssetLoadUI.Enabled == false

print("[Startup OK]")

-------------------------------------------------
-- SERVICES / DATA
-------------------------------------------------
local Players = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Data = require(RS.ClientModules.Core.ClientData)

-------------------------------------------------
-- TRADE REMOTES
-------------------------------------------------
local function send_trade(user)
    RS.API["TradeAPI/SendTradeRequest"]:FireServer(Players:WaitForChild(user))
end

local function add_item(unique)
    RS.API["TradeAPI/AddItemToOffer"]:FireServer(unique)
end

local function accept_trade()
    RS.API["TradeAPI/AcceptNegotiation"]:FireServer()
end

local function confirm_trade()
    RS.API["TradeAPI/ConfirmTrade"]:FireServer()
end

-------------------------------------------------
-- MATCH LOGIC (FIXED)
-------------------------------------------------
local function matches_pet(v, trade_name)
    local parts = string.split(trade_name, ",")
    local kind = parts[1]
    local variant = parts[2]

    if v.kind ~= kind then
        return false
    end

    if variant == "neon" then
        return v.properties and v.properties.neon == true
    end

    if variant == "mega" then
        return v.properties and (
            v.properties.mega == true
            or v.properties.mega_neon == true
        )
    end

    return true
end

-------------------------------------------------
-- BUILD PET QUEUE (NO DUPES, NO OVERFLOW)
-------------------------------------------------
local pets_unique_ids = {}

local function build_queue()
    table.clear(pets_unique_ids)
    local added = {}

    for _, v in pairs(Data.get_data()[LocalPlayer.Name].inventory.pets) do
        for _, trade_name in ipairs(getgenv().Config.pets_to_trade) do
            if matches_pet(v, trade_name) then
                if not added[v.unique] then
                    added[v.unique] = true
                    table.insert(pets_unique_ids, v.unique)
                    print("[QUEUE]", v.kind, v.unique)
                end
                break -- VERY IMPORTANT
            end
        end
    end
end

-------------------------------------------------
-- AUTO TRADE STATE MACHINE (FIXED)
-------------------------------------------------
local trade_status = "idle"
local added_this_trade = 0

local function trade_open()
    return LocalPlayer.PlayerGui:FindFirstChild("TradeApp")
        and LocalPlayer.PlayerGui.TradeApp.Frame.Visible
end

local function autotrade()
    -- no trade open → send trade
    if trade_status == "idle" and #pets_unique_ids > 0 and not trade_open() then
        added_this_trade = 0
        trade_status = "sent"
        send_trade(getgenv().Config.username)
        print("[TRADE] Sent")
        return
    end

    -- trade open → add items
    if trade_status == "sent" and trade_open() then
        while #pets_unique_ids > 0 and added_this_trade < 18 do
            local unique = table.remove(pets_unique_ids, 1)
            add_item(unique)
            added_this_trade += 1
            task.wait(0.35)
        end
        trade_status = "confirm"
        return
    end

    -- confirm trade
    if trade_status == "confirm" and trade_open() then
        accept_trade()
        task.wait(0.6)
        confirm_trade()
        return
    end

    -- trade finished → reset for next batch
    if trade_status == "confirm" and not trade_open() then
        trade_status = "idle"
        print("[TRADE] Finished, remaining:", #pets_unique_ids)
    end
end

-------------------------------------------------
-- RUN
-------------------------------------------------
build_queue()
task.wait(3)

while #pets_unique_ids > 0 do
    autotrade()
    task.wait(0.5)
end

print("[DONE] All pets traded")
