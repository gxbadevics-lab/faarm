---------------------------------------------------------------------
-- CONFIG
---------------------------------------------------------------------
task.spawn(function()
    getgenv().Config = {
        inventory = "pets",
        username = "", -- SET THIS
        pets_to_trade = {
            "winter_2025_xmas_tree_sasquatch",
            "winter_2025_xmas_tree_sasquatch,neon",
            "winter_2025_maine_coon",
            "winter_2025_maine_coon,neon",
            "winter_2025_maine_coon,mega"
        }
    }
end)

---------------------------------------------------------------------
-- STARTUP / UI LOAD (RESTORED)
---------------------------------------------------------------------
repeat task.wait(1) until game:IsLoaded()
    and game:GetService("ReplicatedStorage"):FindFirstChild("ClientModules")
    and game:GetService("ReplicatedStorage").ClientModules:FindFirstChild("Core")
    and game:GetService("ReplicatedStorage").ClientModules.Core:FindFirstChild("UIManager")
    and game:GetService("ReplicatedStorage").ClientModules.Core.UIManager.Apps:FindFirstChild("TransitionsApp")
    and game.Players.LocalPlayer.PlayerGui:FindFirstChild("TransitionsApp")
    and game.Players.LocalPlayer.PlayerGui.TransitionsApp:FindFirstChild("Whiteout")

repeat task.wait(1) until game.Players.LocalPlayer.PlayerGui:FindFirstChild("AssetLoadUI")
    and game.Players.LocalPlayer.PlayerGui.AssetLoadUI.Enabled == false

print("[1] UI Loaded")

---------------------------------------------------------------------
-- DEHASH REMOTES (RESTORED + SAFE WAIT)
---------------------------------------------------------------------
local RS = game:GetService("ReplicatedStorage")

repeat task.wait() until RS.ClientModules
    and RS.ClientModules.Core
    and RS.ClientModules.Core:FindFirstChild("RouterClient")

local RouterClient = require(
    RS.ClientModules.Core.RouterClient:WaitForChild("RouterClient")
)

-- wait until init exists and upvalues are ready
repeat task.wait() until pcall(function()
    return getupvalue(RouterClient.init, 7)
end)

for name, remote in pairs(getupvalue(RouterClient.init, 7)) do
    remote.Name = name
end

print("[2] Dehash Done")

---------------------------------------------------------------------
-- ENTER GAME (UNCHANGED LOGIC)
---------------------------------------------------------------------
local function enter_the_game()
    RS.API["TeamAPI/ChooseTeam"]:InvokeServer(
        "Parents",
        { source_for_logging = "intro_sequence" }
    )

    task.wait(1)

    local ui = require(RS.Fsys).load("UIManager")
    ui.set_app_visibility("MainMenuApp", false)
    ui.set_app_visibility("NewsApp", false)
    ui.set_app_visibility("DialogApp", false)

    task.wait(3)

    RS.API["DailyLoginAPI/ClaimDailyReward"]:InvokeServer()
    ui.set_app_visibility("DailyLoginApp", false)
end

enter_the_game()

---------------------------------------------------------------------
-- CHARACTER WAIT
---------------------------------------------------------------------
repeat task.wait() until game.Players.LocalPlayer.Character
    and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

print("[3] In Game")

---------------------------------------------------------------------
-- SERVICES / DATA
---------------------------------------------------------------------
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Data = require(RS.ClientModules.Core.ClientData)

---------------------------------------------------------------------
-- TRADE REMOTES (UNCHANGED)
---------------------------------------------------------------------
local function send_trade(user)
    RS.API["TradeAPI/SendTradeRequest"]:FireServer(Players:WaitForChild(user))
end

local function add_item(unique)
    RS.API["TradeAPI/AddItemToOffer"]:FireServer(unique)
end

local function accept_trade()
    RS.API["TradeAPI/AcceptNegotiation"]:FireServer()
end

local function confirm_trade()
    RS.API["TradeAPI/ConfirmTrade"]:FireServer()
end

---------------------------------------------------------------------
-- MATCH LOGIC (FIXED)
---------------------------------------------------------------------
local function matches_pet(v, trade_name)
    local parts = string.split(trade_name, ",")
    local kind = parts[1]
    local variant = parts[2]

    if v.kind ~= kind then
        return false
    end

    if variant == "neon" then
        return v.properties and v.properties.neon == true
    end

    if variant == "mega" then
        return v.properties and (
            v.properties.mega == true
            or v.properties.mega_neon == true
        )
    end

    return true
end

---------------------------------------------------------------------
-- BUILD QUEUE (NO DUPES)
---------------------------------------------------------------------
local pets_unique_ids = {}

local function build_queue()
    table.clear(pets_unique_ids)
    local added = {}

    for _, v in pairs(Data.get_data()[LocalPlayer.Name].inventory.pets) do
        for _, trade_name in ipairs(getgenv().Config.pets_to_trade) do
            if matches_pet(v, trade_name) then
                if not added[v.unique] then
                    added[v.unique] = true
                    table.insert(pets_unique_ids, v.unique)
                    print("[QUEUE]", v.kind, v.unique)
                end
                break
            end
        end
    end
end

---------------------------------------------------------------------
-- TRADE STATE MACHINE (FIXED)
---------------------------------------------------------------------
local trade_state = "idle"
local added_this_trade = 0

local function trade_open()
    return LocalPlayer.PlayerGui:FindFirstChild("TradeApp")
        and LocalPlayer.PlayerGui.TradeApp.Frame.Visible
end

local function autotrade()
    if trade_state == "idle" and #pets_unique_ids > 0 and not trade_open() then
        added_this_trade = 0
        trade_state = "sent"
        send_trade(getgenv().Config.username)
        print("[TRADE] Sent")
        return
    end

    if trade_state == "sent" and trade_open() then
        while #pets_unique_ids > 0 and added_this_trade < 18 do
            add_item(table.remove(pets_unique_ids, 1))
            added_this_trade += 1
            task.wait(0.35)
        end
        trade_state = "confirm"
        return
    end

    if trade_state == "confirm" and trade_open() then
        accept_trade()
        task.wait(0.6)
        confirm_trade()
        return
    end

    if trade_state == "confirm" and not trade_open() then
        trade_state = "idle"
        print("[TRADE] Finished, remaining:", #pets_unique_ids)
    end
end

---------------------------------------------------------------------
-- RUN
---------------------------------------------------------------------
build_queue()
task.wait(2)

while #pets_unique_ids > 0 do
    autotrade()
    task.wait(0.5)
end

print("[DONE] All trades completed")
