task.wait(40) -- Initial wait before script starts

-- Anti-AFK setup
local VirtualUser = game:GetService("VirtualUser")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local function antiAFK()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end

-- ===================== CONFIG =====================
local CONFIG = {
    pet_id = { "moon_2025_hopbop", "moon_2025_snorgle", "some_pet_3", "some_pet_4" },
    age_potions_per_pet = { -- normal pets
        ["moon_2025_hopbop"] = 2,
        ["moon_2025_snorgle"] = 3,
        ["some_pet_3"] = 0,
        ["some_pet_4"] = 0,
    },
    neon_age_potions_per_pet = { -- neon pets
        ["moon_2025_hopbop"] = 2,
        ["moon_2025_snorgle"] = 3,
        ["some_pet_3"] = 0,
        ["some_pet_4"] = 0,
    },
    goal_normal_count = {},  -- no goals on normal
    goal_neon_count = {},    -- no goals on neon
    goal_meganeon_count = {  -- goal for mega neon pets (1 of each)
        ["moon_2025_hopbop"] = 1,
        ["moon_2025_snorgle"] = 1,
        ["some_pet_3"] = 0,
        ["some_pet_4"] = 0,
    },
    neon_maker = true,
    neon_feeder = true,
    webhook_url = "https://discord.com/api/webhooks/1404060448692895824/tsUAjiD8JQlgL93NqgvQUhmU0k7u9pjaRJ9R2KtVulc8TlmLY-jze_jiv7U7u9qv64wj",
}
-- ===================================================

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local character = player.Character or player.CharacterAdded:Wait()

local ClientData = require(ReplicatedStorage.ClientModules.Core.ClientData)
local EquipPetRemote = ReplicatedStorage.API["ToolAPI/Equip"]
local FeedPotionRemote = ReplicatedStorage.API["PetObjectAPI/CreatePetObject"]
local NeonFusionRemote = ReplicatedStorage.API["PetAPI/DoNeonFusion"]
local MegaNeonFusionRemote = ReplicatedStorage.API["PetAPI/DoMegaNeonFusion"]

local latestPets = {}
local latestPotions = {}

-- Webhook functions
local function SendMessage(url, message, ping)
    local headers = { ["Content-Type"] = "application/json" }
    local data = { ["content"] = (ping and "<@1277143046173229097> " or "") .. message }
    local body = HttpService:JSONEncode(data)
    request({Url = url, Method = "POST", Headers = headers, Body = body})
    print("Webhook message sent")
end

local function SendMessageEMBED(url, embed, ping)
    local headers = { ["Content-Type"] = "application/json" }
    local data = { ["content"] = ping and "<@1277143046173229097>" or "", ["embeds"] = { embed } }
    local body = HttpService:JSONEncode(data)
    request({Url = url, Method = "POST", Headers = headers, Body = body})
    print("Webhook embed sent")
end

local function sendWebhookMessage(msg, ping) SendMessage(CONFIG.webhook_url, msg, ping) end
local function sendWebhookEmbed(embed, ping) SendMessageEMBED(CONFIG.webhook_url, embed, ping) end

coroutine.wrap(function()
    while true do
        local data = ClientData.getdata and ClientData.getdata() or ClientData.get_data and ClientData.get_data()
        if data and data[player.Name] and data[player.Name].inventory then
            latestPets = data[player.Name].inventory.pets or {}
            latestPotions = {}
            for _, item in pairs(data[player.Name].inventory.food or {}) do
                if item.kind == "pet_age_potion" then
                    table.insert(latestPotions, item)
                end
            end
        else
            latestPets = {}
            latestPotions = {}
        end
        task.wait(5)
    end
end)()

local function potionExists(uniqueID)
    for _, pot in pairs(latestPotions) do
        if pot.unique == uniqueID then return true end
    end
    return false
end

local function equipPet(encodedPetId)
    local args = {
        [1] = encodedPetId,
        [2] = {
            ["use_sound_delay"] = true,
            ["equip_as_last"] = false,
        },
    }
    local success, err = pcall(function() EquipPetRemote:InvokeServer(unpack(args)) end)
    if not success then warn("Failed to equip pet:", encodedPetId, err)
    else print("Equipped pet:", encodedPetId) end
end

local function feedOnePotionAndWaitForConsume(petEncodedID, potionUniqueID)
    local myCFrame = character:FindFirstChild("HumanoidRootPart") and character.HumanoidRootPart.CFrame or CFrame.new()
    local args = {
        [1] = "__Enum_PetObjectCreatorType_2",
        [2] = {
            ["pet_unique"] = petEncodedID,
            ["spawn_cframe"] = myCFrame,
            ["additional_consume_uniques"] = {},
            ["unique_id"] = potionUniqueID,
        }
    }

    print("Feeding potion", potionUniqueID, "to pet", petEncodedID)
    local success, result = pcall(function() return FeedPotionRemote:InvokeServer(unpack(args)) end)
    if not success then
        warn("Feed failed:", result)
        return false
    end

    for i = 1, 100 do -- max 10 sec wait
        task.wait(0.1)
        if not potionExists(potionUniqueID) then
            print("Potion", potionUniqueID, "consumed")
            return true
        end
    end

    warn("Potion", potionUniqueID, "not consumed after 10 seconds")
    return true
end

local function feedPetOneByOne(pet, potionsCount)
    local potionsUsed = 0
    if potionsCount > #latestPotions then
        potionsCount = #latestPotions
        warn("Not enough potions available, feeding only " .. potionsCount)
    end
    for i = 1, potionsCount do
        local potion = latestPotions[i]
        local success = feedOnePotionAndWaitForConsume(pet.unique, potion.unique)
        if not success then break end
        potionsUsed = potionsUsed + 1
    end
    return potionsUsed
end

local function countPetsByFormAndAge(petID)
    local normalAge6, normalAge0, neonAge6, neonAge0, megaCount = 0, 0, 0, 0, 0
    for _, pet in pairs(latestPets) do
        if pet.id == petID then
            local age = pet.properties and pet.properties.age or 0
            local isNeon = pet.properties and pet.properties.neon
            local isMega = pet.properties and pet.properties.mega_neon
            if isMega then megaCount = megaCount + 1
            elseif isNeon then
                if age == 6 then neonAge6 = neonAge6 + 1
                elseif age == 0 then neonAge0 = neonAge0 + 1 end
            else
                if age == 6 then normalAge6 = normalAge6 + 1
                elseif age == 0 then normalAge0 = normalAge0 + 1 end
            end
        end
    end
    return {normalAge6 = normalAge6, normalAge0 = normalAge0, neonAge6 = neonAge6, neonAge0 = neonAge0, mega = megaCount}
end

local function getPetName(petID)
    local names = {
        ["moon_2025_hopbop"] = "Hopbop",
        ["moon_2025_snorgle"] = "Snorgle",
        ["some_pet_3"] = "Some Pet 3",
        ["some_pet_4"] = "Some Pet 4",
    }
    return names[petID] or petID
end

local function generateInventorySummary()
    local summaryLines = {}
    for _, petID in ipairs(CONFIG.pet_id) do
        local counts = countPetsByFormAndAge(petID)
        local line = string.format("%s: Normal %d/0 | Neon %d/0 | Mega %d/%d",
            getPetName(petID), counts.normalAge6, counts.normalAge0, counts.neonAge6, counts.neonAge0, counts.mega, CONFIG.goal_meganeon_count[petID] or 0)
        table.insert(summaryLines, line)
    end
    return table.concat(summaryLines, "\n")
end

local function tryFusionsFirst()
    local fusionDone = false

    for _, petID in ipairs(CONFIG.pet_id) do
        -- Neon fusion: If 4 normal age 6 pets found, fuse to neon
        local counts = countPetsByFormAndAge(petID)
        if counts.normalAge6 >= 4 then
            local candidates = {}
            for _, pet in pairs(latestPets) do
                if pet.id == petID and not pet.properties.neon and pet.properties.age == 6 then
                    table.insert(candidates, pet.unique)
                end
            end
            while #candidates >= 4 do
                local group = {table.unpack(candidates, 1, 4)}
                print("Neon fusion on", petID, "pets:", table.concat(group, ", "))
                local args = { [1] = group }
                local success, err = pcall(function()
                    NeonFusionRemote:InvokeServer(unpack(args))
                end)
                if success then
                    sendWebhookEmbed({
                        title = "‚ú® Neon Fusion Performed",
                        description = string.format("Player %s performed neon fusion on pets: %s (PetID: %s)", player.Name, table.concat(group, ", "), getPetName(petID)),
                        color = 0x00FF00,
                        footer = { text = "Pet Neon Notification" }
                    })
                    fusionDone = true
                    for i = 1, 4 do table.remove(candidates, 1) end
                else
                    warn("Neon fusion failed:", err)
                    break
                end
                task.wait(2)
            end
        end

        -- Mega neon fusion: if 4 neon pets (age 0 or 6) found, fuse to mega neon
        counts = countPetsByFormAndAge(petID) -- refresh counts after possible neon fusion
        if counts.neonAge6 + counts.neonAge0 >= 4 then
            local candidates = {}
            for _, pet in pairs(latestPets) do
                if pet.id == petID and pet.properties.neon and
                   (pet.properties.age == 0 or pet.properties.age == 6) then
                    table.insert(candidates, pet.unique)
                end
            end
            while #candidates >= 4 do
                local group = {table.unpack(candidates, 1, 4)}
                print("Mega neon fusion on", petID, "pets:", table.concat(group, ", "))
                local args = { [1] = group }
                local success, err = pcall(function()
                    MegaNeonFusionRemote:InvokeServer(unpack(args))
                end)
                if success then
                    sendWebhookEmbed({
                        title = "üåü Mega Neon Fusion Performed",
                        description = string.format("Player %s performed mega neon fusion on pets: %s (PetID: %s)", player.Name, table.concat(group, ", "), getPetName(petID)),
                        color = 0xFFD700,
                        footer = { text = "Pet Mega Neon Notification" }
                    }, true)
                    fusionDone = true
                    for i = 1, 4 do table.remove(candidates, 1) end
                else
                    warn("Mega neon fusion failed:", err)
                    break
                end
                task.wait(2)
            end
        end
    end

    return fusionDone
end

local function feedPetsWithLogic()
    local anyActionTaken = false
    local missingPotions = false

    -- First attempt all fusions before anything else
    local fusionPerformed = tryFusionsFirst()
    if fusionPerformed then
        -- If fusion done, return early and wait next cycle
        return true
    end

    for _, petID in ipairs(CONFIG.pet_id) do
        local counts = countPetsByFormAndAge(petID)
        local megaGoal = CONFIG.goal_meganeon_count[petID] or 0
        local neonGoal = CONFIG.goal_neon_count[petID] or 0
        local normalGoal = CONFIG.goal_normal_count[petID] or 0
        local normalPotions = CONFIG.age_potions_per_pet[petID] or 0
        local neonPotions = CONFIG.neon_age_potions_per_pet[petID] or 0

        -- Mega neon goal met?
        if megaGoal > 0 and counts.mega >= megaGoal then
            print(petID .. " mega neon goal met.")
        else
            -- Age neon pets from 0 to 6 if possible
            if counts.neonAge0 > 0 and neonPotions > 0 then
                for _, pet in pairs(latestPets) do
                    if pet.id == petID and pet.properties and pet.properties.neon and pet.properties.age == 0 then
                        equipPet(pet.unique)
                        task.wait(1)
                        feedPetOneByOne(pet, neonPotions)
                        sendWebhookMessage(string.format("üêæ Player %s aged neon pet to 6! Pet: %s (UniqueID: %s)", player.Name, getPetName(petID), pet.unique))
                        task.wait(1)
                        anyActionTaken = true
                    end
                end
            end

            -- Age normal pets if goal not met
            if normalGoal == 0 or counts.normalAge6 < normalGoal then
                if #latestPotions < normalPotions then
                    missingPotions = true
                else
                    for _, pet in pairs(latestPets) do
                        if pet.id == petID and (not pet.properties.neon) and pet.properties.age < 6 then
                            equipPet(pet.unique)
                            task.wait(1)
                            feedPetOneByOne(pet, normalPotions)
                            sendWebhookMessage(string.format("üêæ Player %s aged normal pet to 6! Pet: %s (UniqueID: %s)", player.Name, getPetName(petID), pet.unique))
                            task.wait(1)
                            anyActionTaken = true
                        end
                    end
                end
            end
        end
    end

    if not anyActionTaken then
        local summary = generateInventorySummary()
        if missingPotions then
            sendWebhookMessage(string.format("‚ö†Ô∏è Player %s does not have enough age potions to continue.\n%s", player.Name, summary), true)
        else
            sendWebhookMessage(string.format("‚ÑπÔ∏è Looked and no pet to fuse or feed.\n\nPlayer %s\n%s", player.Name, summary))
        end
        print("Kicking player:", player.Name)
        task.wait(3)  -- wait a bit to ensure webhook sends
        player:Kick("No tasks left or insufficient potions.")
        return false -- indicate no action, stop the loop
    end
    return anyActionTaken
end

local afkTimer = 0
local afkInterval = 60 -- seconds

while true do
    afkTimer = afkTimer + 10
    if afkTimer >= afkInterval then
        antiAFK()
        afkTimer = 0
    end

    local didSomething = feedPetsWithLogic()
    if not didSomething then
        break -- stop running script after kick
    end

    task.wait(40) -- wait 40 seconds between loops
end
